<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>TBV Exchanger Plugin</title>
</head>

<body>
<h1><span lang="EN-GB">The Network Access Plugin</span></a><span lang="EN-GB">                          </span><span lang="EN-GB">(v1.7)</span></h1>
<p><span lang="EN-GB">The network interface opens custom access to data that is internally used by Turbo-BrainVoyager (TBV) during and after real-time processing including information of ROI, design matrix, (pre-processed) raw data and statistical information inclusive the content of the design matrix, beta maps and contrast t-maps. This plugin allows to perform additional operations and calculations outside the TBV.</span></p>
<p><span lang="EN-GB">Well defined access queries are used to get access to the data via a TCP connection. Therefore a server implementation allows to get access to the whole data that is also provided by the plugin interface during and after the real-time processing.</span></p>
<p><span lang="EN-GB">A server client approach is used to get access to the data at any time. Therefore the server provides all features to get access to the data in real-time while running the analysis.</span></p>
<p><span lang="EN-GB">Send a data specific query to get the requested information from the server.</span></p>
<h1><span lang="EN-GB">Connect to the server</span></h1>
<p><span lang="EN-GB">A connection to the server could be established through a TCP socket implementation.</span></a><span lang="EN-GB"> At first the specific server port has to be defined in the plugin. After that the IP of the server will be displayed in the plugin window. </span></a><span lang="EN-GB">The ports range from 1 to 65535 but the first 1024 well-known ports or system ports are used by system processes and need superuser privileges on Unix-like systems to bind a network socket to it. Be sure to use a TCP socket to connect the server.</span></p>
<p><span lang="EN-GB">The plugin uses two different sockets. One to receive and answer the queries from the client and one to send execution information from the TBV. To specify the socket to use send a ("</span><span lang="EN-GB">Request Socket</span><span lang="EN-GB">") char array for the query socket or a ("</span><span lang="EN-GB">Execute Socket</span><span lang="EN-GB">") char array for the execution information socket (prepend the size of the array as a 4 byte unsigned integer for all char arrays and end the array with a NUL [\0]). Include the specific char array into a byte array and insert as the first element the size of the byte array as an 8 byte signed 64bit integer. An example byte based representation is shown below:</span></p>
<p><span lang="EN-GB"> </span></p>
<p><img src="NetworkPlugin_guide_files/image001.png" alt="" width="665" height="18" id="Diagram 8"></p>
<p><img src="NetworkPlugin_guide_files/image002.png" alt="" width="665" height="18" id="Diagram 2"></p>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">If the request is wrong the connection will be closed. Insert a short delay from around 0.5 seconds between the different socket connection requests to be ensure that the server is listening for a new connection.</span></p>
<p><span lang="EN-GB">After the connection is completely established the data can be directly accessed from TBV. Only ask for data that is already available in TBV, otherwise an error message will be returned!</span></p>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">All data that is send and received is in </span><strong><span lang="EN-GB">big-endian</span></strong><span lang="EN-GB"> (<em>network byte) </em></span><strong><span lang="EN-GB">byte order</span></strong><span lang="EN-GB">.</span></p>
<h1><span lang="EN-GB">Access the data</span></h1>
<p><span lang="EN-GB">A query with the included request of the specific data must be send to the server to access the data from the TBV. Every query is defined on the next pages of this guide.</span></p>
<p><span lang="EN-GB">A query has to be constructed as a byte array where the first element is a definition of the size of the byte array as an 8 byte signed 64bit integer.</span></p>
<p><span lang="EN-GB">The second entry defines the type of query as a char array. After that follows the specific query definitions, for example the time point from which to get the data. Only ask for data that are already available in the TBV otherwise an error string ("</span><span lang="EN-GB">Wrong request!</span><span lang="EN-GB">") will be returned.</span></p>
<p><img src="NetworkPlugin_guide_files/image003.png" alt="" width="665" height="19" id="Diagram 3"></p>
<p><span lang="EN-GB">If the query consists of more than one parameter, attach the other parameters to the query and store it in the byte array.</span></p>
<p><span lang="EN-GB">You will receive a byte array with the respective content as answer. (The first 8 byte of the byte array represents the size of the received byte array as unsigned 64bit integer.) As an example how a definition of the byte array should look like, see the &ldquo;tGetCurrentTimePoint&rdquo; example below (send and receive).</span></p>
<p><img src="NetworkPlugin_guide_files/image004.png" alt="" width="666" height="18" id="Diagram 4"></p>
<p><img src="NetworkPlugin_guide_files/image005.png" alt="" width="666" height="18" id="Diagram 5"></p>
<h1><span lang="EN-GB">Prestep, Poststep, Postrun calls</span></h1>
<p><span lang="EN-GB">Whenever new data is available a specific information will be send to the client. The calls are distinguished into a Prestep, Poststep and a Postrun call. The Prestep call will be send whenever new raw data is available. The Poststep call will be send whenever new pre-processed data is available. The Postrun call will be send when the experiment is completely finished or interrupted by the user. This invocation consists of an at least 14 byte large char array followed by an integer representing the current point in time of the current TBV processing. Both data will be send as a byte array </a>(The first 8 byte of the byte array represents the size of the received byte array as signed 64bit integer)</a></span></p>
<p><span lang="EN-GB"> </span></p>
<h1><span lang="EN-GB">Wrong requests</span></h1>
<p><span lang="EN-GB">Whenever the user sends a wrong query (for example asked for a time point that has not been processed yet) a wrong request information will be send to the client. The first part of the information is the definition that a wrong request was asked. After that follows the description which specific part of the query is wrong. The client receives a 14 byte char array (&ldquo;Wrong request!&rdquo;) followed by an char array including the respective error. Keep in mind that this data will also be send in a byte array.</span></a><span lang="EN-GB"> (The first 8 byte of the byte array represents the size of the received byte array as unsigned 64bit integer and before each char array the specific length as a 4byte unsigned integer.)</span></p>
<p><img src="NetworkPlugin_guide_files/image006.png" alt="" width="665" height="34" id="Diagram 6"></p>
<h1><span lang="EN-GB">Basic Project Queries</span></h1>
<p></a><span lang="EN-GB">Send</span></a><span lang="EN-GB">:</span><strong><span lang="EN-GB"> </span></strong><strong><span lang="EN-GB">tGet</span></strong></a><strong><span lang="EN-GB">CurrentTimePoint</span></strong></a></p>
<p><span lang="EN-GB">Receive:</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">CurrentTimePoint</span></p>
<p><span lang="EN-GB">Provides the number of the currently processed step during real-time processing as an integer. Note that this function is 1-based, i.e. when the first step is processed the function returns "1" not "0"; this is important when the return value is used to access time-related information; in this case subtract "1" from the returned value.</span></a></p>
<p><span lang="EN-GB"> </span></p>
<p></a><span lang="EN-GB">Send</span></a><span lang="EN-GB">: </span><strong><span lang="EN-GB">tGetExpectedNrOfTimePoints</a></span></strong></p>
<p><span lang="EN-GB">Receive:</a></span><strong><span lang="EN-GB"> </span></strong></a><span lang="EN-GB">int</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">NrOfTimePoints</span></p>
<p><span lang="EN-GB">Provides the number of time points as an integer. The name contains the term "expected" since a real-time run might be interrupted by the user, i.e. this is the intended number of volumes as specified in the TBV settings file.</span></p>
<p><span lang="EN-GB">Send:</span></a><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetDimsOfFunctionalData</span></strong></p>
<p><span lang="EN-GB">Receive: int dim_x, int dim_y, int dim_z</span></p>
<p><span lang="EN-GB">Provides the dimensions of the functional volumes; "dim_x" and "dim_y" are the dimensions of the slices constituting the volume and "dim_z" corresponds to the number of slices. Example of a Bytearray answer:</span></p>
<p><img src="NetworkPlugin_guide_files/image007.png" alt="" width="665" height="26" id="Diagram 7"></p>
<p><span lang="EN-GB">Send:</span></a><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetProjectName</span></strong></p>
<p><span lang="EN-GB">Receive:</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">char[100]</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">cProjectName</span></p>
<p><span lang="EN-GB">Provides the name of the project as specified in the TBV file as a C string; note that the received data must point to a pre-allocated array that is large enough (a buffer of 100 bytes should be sufficient). The returned name can, for example, be used as part of names identifying exported data (see example "Export Volume Data" client).</span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetWatchFolder</span></strong></p>
<p><span lang="EN-GB">Receive</span></a><span lang="EN-GB">:</span><span lang="EN-GB"> </span><span lang="EN-GB">char[513]</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">cWatchFolder</span></p>
<p><span lang="EN-GB">Provides the path of the "watch folder" as specified in the TBV file as a C string; Note that the received data must point to a pre-allocated array that is large enough for the returned path (a buffer of 513 bytes is recommended).</span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetTargetFolder</span></strong></p>
<p><span lang="EN-GB">Receive:</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">char[513]</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">cTargetFolder</span></p>
<p><span lang="EN-GB">Provides the path of the "target folder" as specified in the TBV file as a C string; note that the received data must point to a pre-allocated array that is large enough for the returned path (a buffer of 513 bytes is recommended). The target folder can be used to export data for custom processing (see example "Export Volume Data" client).</span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetFeedbackFolder</span></strong></p>
<p><span lang="EN-GB">Receive:</span></a><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">char[513]</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">cFeedbackFolder</span></p>
<p><span lang="EN-GB">Provides the path of the "feedback folder" as specified in the TBV file as a C string; note that the provided data must point to a pre-allocated array that is large enough for the received path (a buffer of 513 bytes is recommended). The feedback folder can be used to store the result of custom calculations, e.g. providing custom input for the "Presenter" software tool.</span></p>
<h1><span lang="EN-GB">Protocol, DM, GLM Queries</span></h1>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">Send:</span></a><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetCurrentProtocolCondition</span></strong></p>
<p><span lang="EN-GB">Receive:</span></a><span lang="EN-GB"> int</a> CurrentProtocolCondition</span></p>
<p><span lang="EN-GB">Provides the index of the currently "active" condition of the protocol (0-based), i.e. the condition that has a defined interval enclosing the current time point.</span></p>
<p><span lang="EN-GB">Send:</span></a><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetFullNrOfPredictors</span></strong></p>
<p></a><span lang="EN-GB">Receive:</span></a><span lang="EN-GB"> int</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">FullNrOfPredictors</span></p>
<p><span lang="EN-GB">Provides the number of predictors of the design matrix. Note that this query returns the "full" number of intended predictors while the "tGetCurrentNrOfPredictors" returns the number of predictors currently in use.</span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetCurrentNrOfPredictors</a></span></strong></p>
<p><span lang="EN-GB">Receive:</span></a><span lang="EN-GB"> </span><span lang="EN-GB">int</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">CurrentNrOfPredictors</span></p>
<p><span lang="EN-GB">Provides the currently effective number of predictors. Note that this query may return a smaller number than the "tGetFullNrOfPredictors" query since the internal GLM calculations use a restricted set of predictors in case that for one or more predictors not enough non-zero data points are available. Roughly speaking, the number of current predictors increases each time when a new condition is encountered during real-time processing.</span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetNrOfConfoundPredictors</a></span></strong></p>
<p><span lang="EN-GB">Receive: </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">NrOfConfoundPredictors</span></p>
<p><span lang="EN-GB">Provides the full number of confound predictors. To get the full/effective number of predictors-of-interest, subtract the returned value from the "tGetFullNrOfPredictors" or "tGetCurrentNrOfPredictors" function, respectively.</span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetValueOfDesignMatrix</a></span></strong><span lang="EN-GB">,</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span></a><span lang="EN-GB"> </span><span lang="EN-GB">pred,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">timepoint</span></p>
<p><span lang="EN-GB">Receive</span></a><span lang="EN-GB">: int</span><span lang="EN-GB"> </span><span lang="EN-GB">pred,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">timepoint, </span><span lang="EN-GB">float</span><span lang="EN-GB"> </span><span lang="EN-GB">ValueOfDesignMatrix</span></p>
<p><span lang="EN-GB">Provides the value of a predictor at a given time point of the current design matrix. Note that the design matrix always contains the "full" set of predictors, a reduced set of predictors is only used internally (predictors that are not used internally are those containing only "0.0" entries up to the current time point). Note that the "timepoint" parameter must be smaller than the value returned by the "tGetCurrentTimePoint" </a>query. For details, see the provided example clients.</span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetNrOfContrasts</a></span></strong></p>
<p><span lang="EN-GB">Receive: int</span></a><span lang="EN-GB"> </span><span lang="EN-GB">NrOfContrasts</span></p>
<p><span lang="EN-GB">Provides the number of (automatically or manually) specified contrasts in the TBV settings file. This value is important for accessing t maps, see the "tGetMapValueOfVoxel" and "tGetContrastMaps" queries.</span></p>
<p><span lang="EN-GB"> </span></p>
<strong><span lang="EN-GB"><br clear="all">
</span></strong>
<p><span lang="EN-GB"> </span></p>
<h1><span lang="EN-GB">ROI Queries</span></h1>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">Send:</span></a><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetNrOfROIs</a></span></strong></p>
<p><span lang="EN-GB">Receive: int </span><span lang="EN-GB">NrOfROIs</span></p>
<p><span lang="EN-GB">Provides the number of currently available ROIs. Note that the number of ROIs may change during real-time processing since the user may open additional ROI windows or close ROI windows at any time. It is thus important to use this function prior to other functions accessing ROI information.</span></p>
<p><span lang="EN-GB">Send: </span><strong><span lang="EN-GB">tGetMeanOfROI</a></span></strong><span lang="EN-GB">, </span><span lang="EN-GB">int</span></a><span lang="EN-GB"> </span><span lang="EN-GB">roi</span></p>
<p><span lang="EN-GB">Receive: int</span><span lang="EN-GB"> </span><span lang="EN-GB">roi,</span><span lang="EN-GB"> float </span><span lang="EN-GB">MeanOfROI</span></p>
<p><span lang="EN-GB">Returns the mean signal value of the ROI referenced with the "roi" parameter (0-based index). A valid number must be smaller than the value returned by the "tGetNrOfROIs" query. Note that the voxels defining a ROI might change in case that the user selects another region for the same ROI index (replaces the content of the same plot in the GUI). The query should be used in situations when ROIs are not changed, i.e. when a set of ROIs is pre-loaded for a neurofeedback study. For details, see the "ROI Processing" example client.</span></p>
<p><span lang="EN-GB">Send: </span><strong><span lang="EN-GB">tGetExistingMeansOfROI</span></strong><span lang="EN-GB">, </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">roi, </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">toTimePoint</span></p>
<p><span lang="EN-GB">Receive: int</span><span lang="EN-GB"> </span><span lang="EN-GB">roi,</span><span lang="EN-GB"> int</span><span lang="EN-GB"> </span><span lang="EN-GB">toTimePoint</span><span lang="EN-GB">, float</span><span lang="EN-GB"> </span><span lang="EN-GB">[toTimePoint] ExistingMeansOfROI</span></p>
<p><span lang="EN-GB">Returns all mean signal values of the ROI referenced with the "roi" parameter (0-based index) to the specified point in time. A valid ROI number must be smaller than the value returned by the "tGetNrOfROIs" query. Note that the voxels defining a ROI might change in case that the user selects another region for the same ROI index (replaces the content of the same plot in the GUI). The query should be used in situations when ROIs are not changed, i.e. when a set of ROIs is pre-loaded for a neurofeedback study. For details, see the "ROI Processing" example client.</span></p>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">Send: </span><strong><span lang="EN-GB">tGetMeanOfROIAtTimePoint</span></strong><span lang="EN-GB">, </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">roi, </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">toTimePoint</span></p>
<p><span lang="EN-GB">Receive: int</span><span lang="EN-GB"> </span><span lang="EN-GB">roi,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">toTimePoint</span><span lang="EN-GB">, </span><span lang="EN-GB">float</span><span lang="EN-GB"> </span><span lang="EN-GB">MeanOfROIAtTimePoint</span></p>
<p><span lang="EN-GB">Returns the mean signal value of the ROI referenced with the "roi" parameter (0-based index) of a defined point in time. A valid ROI number must be smaller than the value returned by the "tGetNrOfROIs" query, a valid toTimePoint number must be smaller than the value returned by the "tGetCurrentTimePoint" query. Note that the voxels defining a ROI might change in case that the user selects another region for the same ROI index (replaces the content of the same plot in the GUI). The query should be used in situations when ROIs are not changed, i.e. when a set of ROIs is pre-loaded for a neurofeedback study. For details, see the "ROI Processing" example client.</span></p>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGet</span></strong></a><strong><span lang="EN-GB">NrOfVoxelsOfROI</span></strong></a><span lang="EN-GB">,</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">roi</span></p>
<p><span lang="EN-GB">Receive: int</span><span lang="EN-GB"> </span><span lang="EN-GB">roi, </span><span lang="EN-GB">int </span><span lang="EN-GB">NrOfVoxelsOfROI</span></p>
<p><span lang="EN-GB">Provides the number of voxels of the specified ROI. Note that the returned number might change during real-time processing in case that the user replaces a ROI with another set of voxels. The value of this query is important for accessing information of individual ROI voxels (see below).</span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetBetaOfROI</a></span></strong><span lang="EN-GB">, </span><span lang="EN-GB">int</span></a><span lang="EN-GB"> </span><span lang="EN-GB">roi,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">beta</span></p>
<p><span lang="EN-GB">Receive: int</span><span lang="EN-GB"> </span><span lang="EN-GB">roi,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">beta, </span><span lang="EN-GB">float </span><span lang="EN-GB">BetaOfROI</span></p>
<p><span lang="EN-GB">Retrieves the value of a specified beta (0-based index) of the specified ROI (0-based index). For each ROI a GLM is calculated incrementally using the mean signal time course; the betas of the calculated GLM are accessible with this query; note that the beta indices range from 0 to the full number of predictors; to retrieve only the betas of the predictors of interest, the beta index must be smaller than "tGetFullNrOfPredictors" minus "tGetNrOfConfoundPredictors". For details, see the "ROI Processing" example client.</span></p>
<p><span lang="EN-GB">Send:</span></a><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetCoordsOfVoxelOfROI</span></strong><span lang="EN-GB">,</span><strong><span lang="EN-GB"> </span></strong></a><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">roi,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">voxel</span></p>
<p><span lang="EN-GB">Receive: </span></a><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">roi,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">voxel, </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">x,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">y,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">z</span></p>
<p><span lang="EN-GB">Provides the coordinates of a voxel (0-based enumeration index) of the ROI specified with the "roi" parameter (0-based index); the value for the "voxel" index ranges from "0" to one less than the value returned by the "tGetNrOfVoxelsOfROI" query</a>; since ROIs content may change, use the latter function for a specific ROI index always before using the current function. For details, see the "ROI Processing" example client.</a></span></p>
<p><span lang="EN-GB">Send:</span></a><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetAllCoordsOfVoxelsOfROI</a></span></strong><span lang="EN-GB">,</span><strong><span lang="EN-GB"> </span></strong></a><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">roi</span></p>
<p><span lang="EN-GB">Receive: </span></a><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">roi,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">[</a>tGetNrOfVoxelsOfROI</a>(roi)*3] CoordsOfVoxelsOfROI</span></p>
<p><span lang="EN-GB">Provides the coordinates of all voxels of the ROI specified with the "roi" parameter (0-based index); since ROIs content may change, use the latter function for a specific ROI index always before using the current function. For details, see the "ROI Processing" example plugin. </span><span lang="EN-GB">If a coordinate of a specific voxel of a roi needs to be accessed, use the term "</a>x_coord = </a>voxel_roi</a>+0; y_coord = voxel_roi+1; z_coord = voxel_roi+2". For details, see the "ROI Processing" example client.</span></p>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB"> </span></p>
<strong><span lang="EN-GB"><br clear="all">
</span></strong>
<p><span lang="EN-GB"> </span></p>
<h1><span lang="EN-GB">Volume Data Access Queries</span></h1>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetValueOfVoxelAtTime</span></strong><span lang="EN-GB">,</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span></a><span lang="EN-GB"> </span><span lang="EN-GB">x,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">y,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">z,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">timePoint</span></p>
<p><span lang="EN-GB">Receive: int</span><span lang="EN-GB"> </span><span lang="EN-GB">x,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">y,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">z,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">timepoint,</span><span lang="EN-GB"> float </span><span lang="EN-GB">ValueOfVoxelAtTime</span></p>
<p><span lang="EN-GB">Provides the signal value as a 4-byte float value of the voxel specified by the coordinate parameters "x", "y" and "z" for the given time point (0-based indices). The given "timepoint" parameter must be smaller than the value obtained by the "tGetCurrentTimePoint" query.</span></p>
<p><span lang="EN-GB">Send: </span><strong><span lang="EN-GB">tGetValueOfAllVoxelsAtTime</span></strong><span lang="EN-GB">,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">timePoint</span></p>
<p><span lang="EN-GB">Receive: short int</span><span lang="EN-GB"> [dim_x*dim_y*dim_z] TimeCourseData</span></p>
<p><span lang="EN-GB">Provides the signal value of all voxels to a given time point that is also used internally in TBV. Individual values are 2-byte short integers. Note that the "timepoint" parameter must be smaller than the value returned by the "tGetCurrentTimePoint()" function. If a voxel with specific coordinates needs to be accessed, use the term "z_coord*dim_x*dim_y + y_coord*dim_x + x_coord". For details, see the provided example clients.</span></p>
<p><span lang="EN-GB">Send: </span><strong><span lang="EN-GB">tGetRawValueOfAllVoxelsAtTime</span></strong><span lang="EN-GB">,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">timePoint</span></p>
<p><span lang="EN-GB">Receive: short int</span><span lang="EN-GB"> [dim_x*dim_y*dim_z] TimeCourseData</span></p>
<p><span lang="EN-GB">Provides raw (not pre-processed) the signal value of all voxels to a given time point that is also used internally in TBV. Individual values are 2-byte short integers. Note that the "timepoint" parameter must be smaller than the value returned by the "tGetCurrentTimePoint()" function. If a voxel with specific coordinates needs to be accessed, use the term "z_coord*dim_x*dim_y + y_coord*</a>dim_x</a> + x_coord". For details, see the provided example clients.</span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetBetaOfVoxel</a></span></strong><span lang="EN-GB">, </span><span lang="EN-GB">int</span></a><span lang="EN-GB"> </span><span lang="EN-GB">beta,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">x,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">y,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">z</span></p>
<p><span lang="EN-GB">Receive: int</span><span lang="EN-GB"> </span><span lang="EN-GB">beta,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">x,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">y,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">z, </span><span lang="EN-GB">double </span><span lang="EN-GB">BetaOfVoxel</span></p>
<p><span lang="EN-GB">Provides the value of a beta indexed by the "beta" parameter as an 8-byte double value for the voxel specified by the coordinate parameters "x", "y" and "z" (0-based indices). This function allows to access estimated beta values resulting from the incremental GLM performed by TBV. Note that the beta index ranges from 0 to the current number of predictors; to retrieve only the betas of the predictors of interest, the beta index must be smaller than "tGetCurrentNrOfPredictors" minus "tGetNrOfConfoundPredictors". For details, see the "Export Volume Data" example client.</span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetBetaMaps</a></span></strong></p>
<p><span lang="EN-GB">Receive:  double [</span><span lang="EN-GB">CurrentNrOfPredictors*dim_x*dim_y*dim_z</a></span><span lang="EN-GB">] </span><span lang="EN-GB">BetaMaps</span></p>
<p><span lang="EN-GB">Provides the full stack of beta maps that is also used internally in TBV. Individual entries are high-precision 8-byte double values. The data is organized as a flat array; in order to obtain the beta value of a specific predictor index for a voxel with specific coordinates, use the term "beta_i*dim_xyz + z_coord*dim_xy + y_coord*dim_x + x_coord". Note that the beta_i index must be in the ranges from 0 to the current number of predictors; to retrieve only the betas of the predictors of interest, the beta index must be smaller than tGetCurrentNrOfPredictors</a>" minus "tGetNrOfConfoundPredictors". For details, see the provided "Export Volume Data" client.</span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetMapValueOfVoxel</a></span></strong><span lang="EN-GB">,</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span></a><span lang="EN-GB"> </span><span lang="EN-GB">map,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">x,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">y,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">z</span></p>
<p><span lang="EN-GB">Receive: int</span><span lang="EN-GB"> </span><span lang="EN-GB">map,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">x,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">y,</span><span lang="EN-GB"> </span><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">z,</span><span lang="EN-GB"> float </span><span lang="EN-GB">MapValueOfVoxel</span></p>
<p><span lang="EN-GB">Provides the value of a t map indexed by the "map" parameter as a 4-byte float value for the voxel specified by the coordinate parameters "x", "y" and "z" (0-based indices). This function allows to access calculated contrast values that are calculated based on the beta values from the incremental GLM performed by TBV. The "map" index ranges from 0 to one less than the number of contrasts specified in the TBV settings file (implicitly or via a specified contrast ".ctr" file); the number of contrasts can be retrieved using the "tGetNrOfContrasts" query</a>. For details, see the "Export Volume Data" example client.</span></p>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetContrastMaps</a></span></strong></p>
<p><span lang="EN-GB">Receive:  float</span><span lang="EN-GB"> </span><span lang="EN-GB">[</span><span lang="EN-GB">tGetNrOfContrasts*dim_x*dim_y*dim_z</span><span lang="EN-GB">] </span><span lang="EN-GB">ContrastMaps</span></p>
<p><span lang="EN-GB">Provides the full stack of contrast maps that is also used internally in TBV. Individual entries are 4-byte float values. The data is organized as a flat array; in order to obtain the t value of a specific contrast map index for a voxel with specific coordinates, use the term "map_i*dim_xyz + z_coord*dim_xy + y_coord*dim_x + x_coord". The "map_i" index ranges from 0 to one less than the number of contrasts specified in the TBV settings file (implicitly or via a specified contrast ".ctr" file); the number of contrasts can be retrieved using the "tGetNrOfContrasts</a>" query. For details, see the provided "Export Volume Data" client.</span></p>
<p><span lang="EN-GB"> </span></p>
<span lang="EN-GB"><br clear="all">
</span>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">SVM Access Functions</span></p>
<p>Since version 3.2 TBV provides access to classification output values calculated during <a href="http://download.brainvoyager.com/tbv/TBVUsersGuide/MVPA/RealTimeSVMClassification.html">real-time SVM classification</a>. The tGetCurrentClassifierOutput() function provides both a single integral value informing which class is predicted at the current time point as well as a detailed vector of float values that can be used for custom classifier-based neurofeedback. The latter information is returned in a vector since the number of values depend on the number of classes used for classification (see below). It is, thus, important to call the tGetNumberOfClasses() function to ensure that the right number of values is used to prepare an array with sufficient size for retrieving the output values. </p>
<p> </p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetNumberOfClasses</span></strong></p>
<p><span lang="EN-GB">Receive: int </span><span lang="EN-GB">n_classes</span></p>
<p><span lang="EN-GB">Provides the number of classes for which values are provided. In case that the real-time SVM classifier is not used, this function returns -3; in case that the real-time SVM classifier dialog is open but the classifier is not producing incremental output, this function returns -2; if the classifier is working but no output has been generated yet, this function returns 0. You only should use the tGetCurrentClassifierOutput() function (see below) if this function returns a positive value. Based on the returned (positive) value (assigned to e.g. variable <em>n_classes</em>), the size of the array needed for the tGetCurrentClassifierOutput() function can be calculated as the number of pair comparisons <em>n_pairs</em>:</span></p>
<p><em>n_pairs</em> = <em>n_classes</em> * (<em>n_classes</em> - 1) / 2</p>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetCurrentClassifierOutput</span></strong></p>
<p><span lang="EN-GB">Receive:  float</span><span lang="EN-GB"> </span><span lang="EN-GB">[</span><span lang="EN-GB">n_pairs</span><span lang="EN-GB">] </span><span lang="EN-GB">ClassifierOutput</span></p>
<p><span lang="EN-GB">Provides results during real-time SVM classification for the current time point. The function returns an integral value indicating which class is predicted, i.e. which class label has been assigned to the current brain activity pattern. Note that the returned value is 1-based, i.e. if the first class is predicted, value 1 is returned, if the second class is predicted, value 2 is returned and so on. In addition to returning the predicted class, the function also fills a provided float array with detailed classification values. Since the SVM procedure internally finds the predicted class ("winner") by comparing the results obtained for all possible unique pairs of classes, the array needs to be large enough to receive all pairwise classification results (for calculation, see above). In case of a two-class problem, the array will contain only one entry for the pair "1 against 2" or "1-2". For multi-class (&gt; 2) problems, the order of pairs will be starting with all pairs containing class 1 on the left side, then all remaining pairs that have class 2 on the left side and so on. For a 3-class problem, the order would be "1-2", "1-3", "2-3" and for a 4-class problem, the order would be "1-2", "1-3", "1-4", "2-3", "2-4" and "3-4". A positive value for a pair indicates that the class on the left side has "won" whereas a negative value indicates that the class on the right side has "won" the respective pairwise comparison; the size of the value(s) may be used to calculate a continuous value as a feedback signal.</span></p>
<p>As with the tGetNumberOfClasses() function, this function returns value -3 in case that the real-time SVM classifier is not open and -2 in case that the real-time SVM classifier dialog is open but the classifier is not producing incremental output. The function returns value -1 if the SVM dialog is used but no output data is available for the current time point. Only access the provided output_array if the returned value of the function is a positive number. Use the tGetNumberOfClasses() function to retrieve the number of classes from which you can calculate the number of pairs (see above) to determine the necessary size of the array used to receive the pairwise classification values. Consult the SVM Plugin sample code for an example how to use the SVM access functions.</p>
<span lang="EN-GB"><br clear="all">
</span>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">Functional Connectivity Functions</span></p>
<p>The plugin provides basic functional connectivity measure like the Pearson correlation or partial correlation. These measures are based on the selected ROI&rsquo;s and calculated for the current and previous points in time and a specified window for the correlation. The correlation results stored in the double PCorrelation[ncon] array can be accessed as shown in the example below:</p>
<p><img border="0" width="657" height="113" src="NetworkPlugin_guide_files/image008.png" alt="int n_rois = tGetNrOfROIs();  int ncon = 0;  for(int i=1; i&lt;n_rois; i++)  		for(int j=i+1; j&lt;=n_rois; j++)  {  printf(“Correlation: ROI %i and ROI %i: %f“,i,j,PCorrelation[ncon]);  ncon++;  }"></p>
<p><span lang="EN-GB">The total number of correlations (ncon) can be calculated using the equation below.</span></p>
<p><span lang="EN-GB"> </span></p>
<p align="center"><em><span lang="EN-GB">int</span></em><span lang="EN-GB"> </span><em>ncon=(n_rois*(n_rois-1))/2; // total number of correlations (edges)</em></p>
<p> </p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetPearsonCorrelation</span></strong><span lang="EN-GB">,</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">windowSize</span></p>
<p><span lang="EN-GB">Receive: double </span><span lang="EN-GB">PearsonCorrelation</span><span lang="EN-GB">[</span><span lang="EN-GB">ncon]</span></p>
<p><span lang="EN-GB">Provides the calculated Pearson Correlation results of the current point in time for all combinations of selected ROI&rsquo;s. At least two ROI&rsquo;s must be selected to calculate a correlation.</span></p>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetPearsonCorrelationAtTimePoint</span></strong><span lang="EN-GB">,</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">windowSize,</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">timePoint</span></p>
<p><span lang="EN-GB">Receive:  double </span><span lang="EN-GB">PearsonCorrelation</span><span lang="EN-GB">[</span><span lang="EN-GB">ncon]</span></p>
<p><span lang="EN-GB">Provides the calculated Pearson Correlation results of the point in time defined by the timePoint parameter for all combinations of selected ROI&rsquo;s. At least two ROI&rsquo;s must be selected to calculate a correlation.</span></p>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetPartialCorrelation</span></strong><span lang="EN-GB">,</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">windowSize</span></p>
<p><span lang="EN-GB">Receive: double </span><span lang="EN-GB">PartialCorrelation</span><span lang="EN-GB">[</span><span lang="EN-GB">ncon]</span></p>
<p><span lang="EN-GB">Provides the calculated partial correlation results of the current point in time for all combinations of selected ROI&rsquo;s. At least two ROI&rsquo;s must be selected to calculate a correlation.</span></p>
<p><span lang="EN-GB"> </span></p>
<p><span lang="EN-GB">Send:</span><span lang="EN-GB"> </span><strong><span lang="EN-GB">tGetPartialCorrelationAtTimePoint</span></strong><span lang="EN-GB">,</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">windowSize,</span><strong><span lang="EN-GB"> </span></strong><span lang="EN-GB">int</span><span lang="EN-GB"> </span><span lang="EN-GB">timePoint</span></p>
<p><span lang="EN-GB">Receive:  double </span><span lang="EN-GB">PartialCorrelation</span><span lang="EN-GB">[</span><span lang="EN-GB">ncon]</span></p>
<p><span lang="EN-GB">Provides the calculated partial correlation results of the point in time defined by the timePoint parameter for all combinations of selected ROI&rsquo;s. At least two ROI&rsquo;s must be selected to calculate a correlation.</span></p>
<p><span lang="EN-GB"> </span></p>
</body>
</html>
